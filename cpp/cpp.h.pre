
#include <isl/ctx.h>
#include <isl/options.h>

#include <functional>
#include <memory>
#include <stdexcept>
#include <string>

namespace isl {

class ctx {
	isl_ctx *ptr;
public:
	/* implicit */ ctx(isl_ctx *ctx) : ptr(ctx) {}
	isl_ctx *release() {
		auto tmp = ptr;
		ptr = nullptr;
		return tmp;
	}
	isl_ctx *get() {
		return ptr;
	}
};

/* Class capturing isl errors.
 *
 * The what() return value is stored in a reference counted string
 * to ensure that the copy constructor and the assignment operator
 * do not throw any exceptions.
 */
class exception : public std::exception {
	std::shared_ptr<std::string> what_str;

protected:
	inline exception(const char *what_arg, const char *msg,
		const char *file, int line);
public:
	exception() {}
	exception(const char *what_arg) {
		what_str = std::make_shared<std::string>(what_arg);
	}
	static inline exception create(enum isl_error error, const char *msg,
		const char *file, int line);
	static inline exception create_from_last_error(isl::ctx ctx);
	virtual const char *what() const noexcept {
		return what_str->c_str();
	}
};

/* Create an exception of a type described by "what_arg", with
 * error message "msg" in line "line" of file "file".
 *
 * Create a string holding the what() return value that
 * corresponds to what isl would have printed.
 * If no error message or no error file was set, then use "what_arg" instead.
 */
exception::exception(const char *what_arg, const char *msg, const char *file,
	int line)
{
	if (!msg || !file)
		what_str = std::make_shared<std::string>(what_arg);
	else
		what_str = std::make_shared<std::string>(std::string(file) +
				    ":" + std::to_string(line) + ": " + msg);
}

class exception_abort : public exception {
	friend exception;
	exception_abort(const char *msg, const char *file, int line) :
		exception("execution aborted", msg, file, line) {}
};

class exception_alloc : public exception {
	friend exception;
	exception_alloc(const char *msg, const char *file, int line) :
		exception("memory allocation failure", msg, file, line) {}
};

class exception_unknown : public exception {
	friend exception;
	exception_unknown(const char *msg, const char *file, int line) :
		exception("unknown failure", msg, file, line) {}
};

class exception_internal : public exception {
	friend exception;
	exception_internal(const char *msg, const char *file, int line) :
		exception("internal error", msg, file, line) {}
};

class exception_invalid : public exception {
	friend exception;
	exception_invalid(const char *msg, const char *file, int line) :
		exception("invalid argument", msg, file, line) {}
};

class exception_quota : public exception {
	friend exception;
	exception_quota(const char *msg, const char *file, int line) :
		exception("quota exceeded", msg, file, line) {}
};

class exception_unsupported : public exception {
	friend exception;
	exception_unsupported(const char *msg, const char *file, int line) :
		exception("unsupported operation", msg, file, line) {}
};

/* Create an exception of the class that corresponds to "error", with
 * error message "msg" in line "line" of file "file".
 *
 * isl_error_none is treated as an invalid error type.
 */
exception exception::create(enum isl_error error, const char *msg,
	const char *file, int line)
{
	switch (error) {
	case isl_error_none:
		break;
	case isl_error_abort: return exception_abort(msg, file, line);
	case isl_error_alloc: return exception_alloc(msg, file, line);
	case isl_error_unknown: return exception_unknown(msg, file, line);
	case isl_error_internal: return exception_internal(msg, file, line);
	case isl_error_invalid: return exception_invalid(msg, file, line);
	case isl_error_quota: return exception_quota(msg, file, line);
	case isl_error_unsupported:
				return exception_unsupported(msg, file, line);
	}

	throw exception_invalid("invalid error type", __FILE__, __LINE__);
}

/* Create an exception from the last error that occurred on "ctx" and
 * reset the error.
 *
 * If "ctx" is NULL or if it is not in an error state at the start,
 * then an invalid argument exception is thrown.
 */
exception exception::create_from_last_error(isl::ctx ctx)
{
	enum isl_error error;
	const char *msg, *file;
	int line;

	error = isl_ctx_last_error(ctx.get());
	msg = isl_ctx_last_error_msg(ctx.get());
	file = isl_ctx_last_error_file(ctx.get());
	line = isl_ctx_last_error_line(ctx.get());
	isl_ctx_reset_error(ctx.get());

	return create(error, msg, file, line);
}

/* Helper class for setting the on_error and resetting the option
 * to the original value when leaving the scope.
 */
class options_scoped_set_on_error {
	isl_ctx *ctx;
	int saved_on_error;
public:
	options_scoped_set_on_error(isl::ctx ctx, int on_error) {
		this->ctx = ctx.get();
		saved_on_error = isl_options_get_on_error(this->ctx);
		isl_options_set_on_error(this->ctx, on_error);
	}
	~options_scoped_set_on_error() {
		isl_options_set_on_error(ctx, saved_on_error);
	}
};

class id {
  friend inline isl::id manage(__isl_take isl_id *ptr);

  isl_id *ptr;

  inline explicit id(__isl_take isl_id *id);
public:
  id(isl::ctx ctx, const std::string &name) {
    ptr = isl_id_alloc(ctx.release(), name.c_str(), nullptr);
  }

  template <typename T>
  id(isl::ctx ctx, const std::string &name, T *usr,
     void (*deleter)(void *) = nullptr) {
    ptr = isl_id_alloc(ctx.release(), name.c_str(), usr);
    if (deleter)
      ptr = isl_id_set_free_user(ptr, deleter);
  }

  template <typename T>
  id(isl::ctx ctx, T *usr,
     void (*deleter)(void *) = nullptr) {
    ptr = isl_id_alloc(ctx.release(), nullptr, usr);
    if (deleter)
      ptr = isl_id_set_free_user(ptr, deleter);
  }

  template <typename T>
  T *get_user() {
    if (!ptr)
      return nullptr;
    return static_cast<T *>(isl_id_get_user(ptr));
  }

  inline /* implicit */ id();
  inline /* implicit */ id(const isl::id &obj);
  inline isl::id &operator=(isl::id obj);
  inline ~id();
  inline __isl_give isl_id *copy() const &;
  inline __isl_give isl_id *copy() && = delete;
  inline __isl_keep isl_id *get() const;
  inline __isl_give isl_id *release();
  inline explicit operator bool() const;
  inline isl::ctx get_ctx() const;
  inline bool is_null() const;
  inline std::string to_str() const;

  inline std::string get_name() const;
  inline int get_hash() const;

  inline bool has_name() const;
  inline isl::id set_free_user(void (*deleter)(void *)) const;
  inline bool operator== (const isl::id &obj) const;
  inline bool operator!= (const isl::id &obj) const;
};

inline isl::id manage(__isl_take isl_id *ptr) {
  return id(ptr);
}

id::id()
    : ptr(nullptr) {}

id::id(const isl::id &obj)
    : ptr(obj.copy()) {}

id::id(__isl_take isl_id *ptr)
    : ptr(ptr) {}

id &id::operator=(isl::id obj) {
  std::swap(this->ptr, obj.ptr);
  return *this;
}

id::~id() {
  if (ptr)
    isl_id_free(ptr);
}

__isl_give isl_id *id::copy() const & {
  return isl_id_copy(ptr);
}

__isl_keep isl_id *id::get() const {
  return ptr;
}

__isl_give isl_id *id::release() {
  isl_id *tmp = ptr;
  ptr = nullptr;
  return tmp;
}

id::operator bool() const {
  return !is_null();
}

isl::ctx id::get_ctx() const {
  return isl::ctx(isl_id_get_ctx(ptr));
}

bool id::is_null() const {
  return ptr == nullptr;
}

inline std::ostream& operator<<(std::ostream& os, const id& C) {
  os << C.to_str();
  return os;
}

std::string id::to_str() const {
  char *Tmp = isl_id_to_str(get());
  if (!Tmp)
    return "";
  std::string S(Tmp);
  free(Tmp);
  return S;
}

int id::get_hash() const {
  return isl_id_get_hash(get());
}

std::string id::get_name() const {
  auto res = isl_id_get_name(get());
  std::string tmp(res);
  return tmp;
}

bool id::has_name() const {
  return isl_id_get_name(get()) != nullptr;
}

id id::set_free_user(void (*deleter)(void *)) const {
  auto res = isl_id_set_free_user(copy(), deleter);
  return manage(res);
}

bool id::operator==(const id &obj) const {
  return ptr == obj.ptr;
}

bool id::operator!=(const id &obj) const {
  return !operator==(obj);
}

enum class dim_type {
  cst = isl_dim_cst,
  param = isl_dim_param,
  in = isl_dim_in,
  out = isl_dim_out,
  set = isl_dim_set,
  div = isl_dim_div,
  all = isl_dim_all
};

enum class ast_op_type {
	error = isl_ast_op_error,
	_and = isl_ast_op_and,
	and_then = isl_ast_op_and_then,
	_or = isl_ast_op_or,
	or_else = isl_ast_op_or_else,
	max = isl_ast_op_max,
	min = isl_ast_op_min,
	minus = isl_ast_op_minus,
	add = isl_ast_op_add,
	sub = isl_ast_op_sub,
	mul = isl_ast_op_mul,
	div = isl_ast_op_div,
	fdiv_q = isl_ast_op_fdiv_q,	/* Round towards -infty */
	pdiv_q = isl_ast_op_pdiv_q,	/* Dividend is non-negative */
	pdiv_r = isl_ast_op_pdiv_r,	/* Dividend is non-negative */
	zdiv_r = isl_ast_op_zdiv_r,	/* Result only compared against zero */
	cond = isl_ast_op_cond,
	select = isl_ast_op_select,
	eq = isl_ast_op_eq,
	le = isl_ast_op_le,
	lt = isl_ast_op_lt,
	ge = isl_ast_op_ge,
	gt = isl_ast_op_gt,
	call = isl_ast_op_call,
	access = isl_ast_op_access,
	member = isl_ast_op_member,
	address_of = isl_ast_op_address_of
};

enum class ast_node_type {
	error = isl_ast_node_error,
	_for = isl_ast_node_for,
	_if = isl_ast_node_if,
	block = isl_ast_node_block,
	mark = isl_ast_node_mark,
	user = isl_ast_node_user
};

enum class ast_loop_type {
	error = isl_ast_loop_error,
	_default = isl_ast_loop_default,
	atomic = isl_ast_loop_atomic,
	unroll = isl_ast_loop_unroll,
	separate = isl_ast_loop_separate
};

enum class schedule_node_type {
        error = isl_schedule_node_error,
        band = isl_schedule_node_band,
        context = isl_schedule_node_context,
        domain = isl_schedule_node_domain,
        expansion = isl_schedule_node_expansion,
        extension = isl_schedule_node_extension,
        filter = isl_schedule_node_filter,
        leaf = isl_schedule_node_leaf,
        guard = isl_schedule_node_guard,
        mark = isl_schedule_node_mark,
        sequence = isl_schedule_node_sequence,
        set = isl_schedule_node_set
};

template <typename T>
class list;

template <typename T>
class list_iterator {
  const list<T> *lst;
  int pos;
  mutable T elementHolder;

  inline list_iterator(const list<T> *l, int p);

  friend list_iterator list<T>::begin() const;
  friend list_iterator list<T>::end() const;

public:
  typedef T value_type;
  typedef int difference_type;
  typedef std::input_iterator_tag iterator_category;
  typedef const T *pointer;
  typedef T reference;

  inline list_iterator();
  inline list_iterator(const list_iterator<T> &it);
  inline ~list_iterator();
  inline list_iterator &operator=(const list_iterator<T> &it);

  inline reference operator*() const;
  inline pointer operator->() const;
  inline list_iterator operator++(int);
  inline list_iterator &operator++();
  inline bool operator==(const list_iterator<T> &it) const;
  inline bool operator!=(const list_iterator<T> &it) const;

  static inline void swap(list_iterator<T> &it1, list_iterator<T> &it2);
};

template <typename T>
list_iterator<T>::list_iterator(const list<T> *l, int p) :
  lst(l), pos(p) {}

template <typename T>
list_iterator<T>::list_iterator() :
  lst(nullptr), pos(-1) {}

template <typename T>
list_iterator<T>::list_iterator(const list_iterator<T> &it) :
  lst(it.lst), pos(it.pos) {}

template <typename T>
list_iterator<T> &list_iterator<T>::operator=(const list_iterator<T> &it) {
  lst = it.lst;
  pos = it.pos;
  return *this;
}

template <typename T>
list_iterator<T>::~list_iterator() {}

template <typename T>
typename list_iterator<T>::reference list_iterator<T>::operator*() const {
  return lst->at(pos);
}

template <typename T>
typename list_iterator<T>::pointer list_iterator<T>::operator->() const {
  elementHolder = lst->at(pos);
  return &elementHolder;
}

template <typename T>
list_iterator<T> list_iterator<T>::operator++(int) {
  list_iterator<T> it = *this;
  ++*this;
  return it;
}

template <typename T>
list_iterator<T> &list_iterator<T>::operator++() {
  if (pos == -1 || !lst || pos >= lst->size() - 1)
    pos = -1;
  else
    ++pos;

  return *this;
}

template <typename T>
bool list_iterator<T>::operator==(const list_iterator<T> &it) const {
  if (lst != it.lst)
    throw std::invalid_argument(
			"cannot compare iterators from different containers");
  return pos == it.pos;
}

template <typename T>
bool list_iterator<T>::operator!=(const list_iterator<T> &it) const {
  return !(*this == it);
}

} // namespace isl
